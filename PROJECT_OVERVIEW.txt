Pump.fun Sell Bot — Project Overview and Next Steps

1) Objectives (from SOW)
- Detect manual buys of pre‑migration Pump.fun tokens from Lee’s wallet.
- Track positions in real time (PnL, price, MCAP via Pump bonding curve state).
- Auto‑sell when exit condition hits (configurable):
  - Fixed TP/SL (e.g., TP +35%, SL −20%) or
  - Trailing stop loss (e.g., 30% trail) — can be toggled.
- Priorities: simplicity, speed, reliability. Out of scope: auto‑buy, LP/migration handling beyond halt.

2) Current Architecture (high level)
- Language/stack: TypeScript (Node.js). Libs: @pump-fun/pump-sdk, @solana/web3.js, @solana/spl-token, bn.js, dotenv.
- Core modules:
  - src/index.ts: startup, config, tracker + detection wiring, graceful shutdown.
  - src/config.ts: env loading/validation and runtime feature flags.
  - src/detection.ts: buy detection via wallet logs (WS primary), tx parsing, and fallback mechanisms.
  - src/tracker.ts: position evaluation loop, PnL calc, sell building + confirmation, manual close detection.
  - src/positions.ts: in‑memory position store (addBuy/update/close) designed to avoid state corruption.
  - src/logger.ts: console + JSON file logging.

3) Detection Strategy
- Primary: WebSocket `onLogs(wallet)` for low‑latency push of new wallet tx signatures.
- Parsing: Fetch parsed tx, confirm Pump program involvement, compute:
  - tokenDelta: owner’s token increase by mint.
  - Accurate buy cost (curve cost): sum of inner SystemProgram transfers from wallet to non‑ATA destinations, excluding ATA rent and network fee. Falls back to wallet lamport delta − tx fee − ATA rent if needed.
- Guards:
  - Ignore old history via process start time.
  - Require positive token increase and positive curve cost.
  - De‑duplication via signature sets and optional polling tip.
- Poll fallback: disabled when WS is active; otherwise a light, tip‑based polling loop.

4) Position Tracking & PnL
- Positions are keyed by mint; buys accumulate tokens and cost (addBuy). State updates (e.g., peak) use update() to avoid re‑adding cost/tokens.
- Cost basis: exact curve cost computed at detection time (excludes tx fee and ATA rent). This matches explorer line items that go into the bonding curve / protocol.
- PnL math: BN‑safe integer math; never uses unsafe JS floats for ratios. PnL% = (solOut − cost) / cost with scaling, then converted to a small Number for logging.
- Marketcap/price: uses Pump SDK bonding curve state; SOL amounts formatted as strings to avoid precision issues.
- Migration/complete: tracking halts and position is closed (no auto‑sell), per SOW.
- Manual close detection: in the tracker loop we use a single getMultipleAccountsInfo via `fetchBuyState` to retrieve bonding curve + associated user account; if ATA missing or its decoded SPL amount is zero → remove position immediately. Avoids extra RPC calls per tick.

5) Sell Logic
- Transaction build:
  - ComputeBudget ixs (unit limit + optional priority fee, configurable in SOL).
  - Pump SDK `sellInstructions` with slippage guard (MAX_SLIPPAGE_BPS).
  - Skip preflight (configurable) for speed.
- Confirmation (toggleable):
  - WS two‑phase (default):
    - Wait for `processed` quickly (fast signal); early resubmit if not observed by `CONFIRM_PROCESSED_TIMEOUT_MS`.
    - Then wait for `confirmed` with `CONFIRM_CONFIRMED_TIMEOUT_MS`.
    - Any `err` immediately treated as failure (no false “confirmed”).
    - One controlled resubmit (total attempts = SELL_MAX_ATTEMPTS).
  - Simple confirm (classic):
    - `confirmTransaction` with chosen commitment and single resubmit on timeout/blockheight expiry.
  - Position is only closed after real success; manual‑close detection provides a backstop if you close on wallet/UI.

6) Strategy Toggle (Fixed vs Trailing)
- `SELL_STRATEGY=fixed`: triggers when PnL% ≥ TP_PCT or ≤ SL_PCT.
- `SELL_STRATEGY=trailing`: maintains `peakSolOut` and sells when current SOL‑out ≤ peak × (1 − TRAILING_SL_BPS/10000). Peak updates never sell on the same tick.
- MIN_HOLD_MS guard prevents instant exits right after buy to absorb spread.

7) Configuration (env) — key variables
- Wallet/RPC:
  - HELIUS_RPC_URL / HELIUS_WS_URL (or ERPC endpoints) — the code accepts any URLs here; names are historical.
  - SOLANA_PRIVATE_KEY — base58/base64/JSON array supported.
- Detection/loop:
  - DETECTION_MODE=auto|ws|poll; POLL_INTERVAL_MS.
  - TRACKER_ENABLED=true|false; SELL_ENABLED=true|false.
  - RUN_FOR_SECONDS (optional short health runs).
- Sell logic:
  - SELL_STRATEGY=fixed|trailing; TP_PCT; SL_PCT; TRAILING_SL_BPS.
  - MAX_SLIPPAGE_BPS (e.g., 1000=10%).
  - PRIORITY_FEE_SOL (e.g., 0.01–0.02 works well under load).
  - SKIP_PREFLIGHT=true|false.
- Confirmation mode:
  - CONFIRM_MODE=ws|simple (default ws).
  - WS: CONFIRM_PROCESSED_TIMEOUT_MS (default 5000), CONFIRM_CONFIRMED_TIMEOUT_MS (12000).
  - Simple: CONFIRM_SIMPLE_COMMITMENT=confirmed, CONFIRM_SIMPLE_TIMEOUT_MS (20000).
  - SELL_MAX_ATTEMPTS=2.

8) Rate‑Limit & Reliability Improvements Implemented
- Primary WS detection; poll fallback disabled when WS active.
- Removed redundant per‑tick balance RPC; decode ATA from the single multi‑account fetch.
- BN‑safe computations and SOL formatting; removed unsafe Number conversions.
- State update refactor (addBuy vs update) to prevent cost/tokens re‑addition.
- Confirmation strategies hardened: early WS resubmit; err‑aware status checks; option to switch to classic confirmTransaction.

9) Running the Bot
- Dev: `npm run dev` (ts‑node).
- Prod: `npm run build && npm start` (from dist/).
- Health: `npm run health:dev` (5‑second run, no sells/tracking) if desired.
- Docker: `docker build -t pumpfun-bot . && docker run --rm --env-file .env pumpfun-bot`.

10) Observability
- Console logs: lifecycle messages — detected buy, position opened, track updates, peak updates (trailing), sell triggers, submission, observation (processed), confirmation path, and position close.
- JSON logs: `bot.log.json` for post‑trade analysis.

11) Known Trade‑offs / Limitations (current)
- In‑memory position store — restarts forget positions; an on‑disk snapshot is out of scope for MVP.
- Confirmation timing depends on RPC/provider load; priority fees help significantly.
- No Jito bundles yet; not required for MVP but useful under extreme contention.
- Multi‑wallet orchestration not implemented (MVP: single wallet).

12) Next Steps (recommended order)
- Optional: Jito bundle submission toggle for sells (improves inclusion and reduces variance).
- Optional: Persistence layer (local JSON snapshot) to restore open positions on restart.
- Optional: Dynamic slippage or re‑quote on slippage error (up to MAX_SLIPPAGE_BPS) with a short cool‑down.
- Optional: Per‑mint telemetry (short, human‑readable progress line) and thinning of verbose logs in steady state.
- Optional: Strategy extensions (e.g., fixed TP + trailing lock‑in, or cool‑downs after sells).
- Optional: Lightweight unit tests for PnL calc, trailing trigger math, and position state merges (BN handling).
- Optional: CI lint/typecheck.

13) Quick Troubleshooting
- “Position closed but logs say confirmed”: Now guarded; we check `err` before success. If still seen, it’s likely a provider UI mismatch; confirm on explorer.
- “429 Too Many Requests”: Ensure only one instance is running; prefer WS mode; avoid per‑tick extra RPC calls; keep priority fees on; consider dedicated RPC plan.
- “PnL looks off”: Ensure basisSource: parsed‑tx is visible in the ‘Position opened’ log and that costLamports equals the curve/protocol amounts on explorer.

This file summarizes the current state of the project, the rationale behind key choices, and actionable next steps. For any follow‑ups (e.g., Jito integration, persistence, or strategy tweaks), we can scope and implement incrementally.
Pump.fun Sniper Bot — Project Overview

1) What We’re Building
- Goal: A low‑latency sniper bot for pump.fun that detects brand‑new token launches on‑chain, evaluates them with strict, fast signals, and auto‑buys the best candidates with robust execution (Jito/Helius Sender), then manages exits.
- Priorities: correctness of on‑chain decoding, minimal false positives, configurable buy conditions, and safe, observable execution.

2) What’s Built So Far (in detail)
- On‑chain create detection (robust):
  - Subscribes to Pump program logs and fetches/decodes create transactions.
  - Handles v0 transactions and address table lookups (uses static + loaded addresses).
  - Scans both top‑level and inner (CPI) instructions for Pump.create.
  - Infers mint even when accounts are omitted via postTokenBalances and parsed SPL‑Token initialize ix.
  - File: src/sources/onchainCreateDetector.ts

- Metadata + social intel:
  - Fetches off‑chain JSON (timeout‑bounded) and normalizes fields.
  - Social gate: Twitter handle must contain token name or symbol (case‑insensitive, alnum). Toggleable.
  - Image gate exists but currently disabled per config.
  - Files: src/sources/metadata.ts, src/gates/social.ts

- On‑chain gating:
  - Creator initial buy: parses inner transfers to compute creator’s SOL spent in the create tx (ex‑ATA rent). Rejects if above threshold.
  - Funder detection (1‑hop): scans recent signatures (limit + timeout), checks creator balance deltas, and searches both top‑level and inner parsed transfers to identify the funding source.
  - Block if funder is also a known token creator (or manually blacklisted if enabled).
  - File: src/gates/onchain.ts

- Persistence (SQLite with JSON fallback):
  - Tables: creators, known_creators, creator_funders. Auto‑migrates from JSON store on first SQLite run.
  - Falls back to data/store.json when better‑sqlite3 is unavailable; transparent adapter.
  - File: src/store_sqlite.ts (fallback: src/store.ts)

- Decision pipeline + logging:
  - Each create produces a “Launch decision snapshot” with all gate reasons, funder, timing, etc.
  - Structured JSON logging to LOG_FILE.
  - Files: src/index.ts, src/logger.ts

- Auto‑buy scaffolding (guarded):
  - Builds buy tx via Pump SDK (compute budget, slippage, priority fee), quotes tokens from BUY_SOL.
  - Optional Jito bundle via Helius Sender: buy tx + tip tx; fallback to single send on failure.
  - Files: src/autoBuy.ts, src/sender/jito_jsonrpc.ts (REST bundles), src/sender/jito.ts (gRPC optional), wired in src/index.ts

- Wallet buy detection + tracker (existing components):
  - startBuyDetection parses wallet buys; Tracker skeleton for exits exists (TP/SL/trailing).
  - Files: src/detection.ts, src/tracker.ts, src/positions.ts

- Configuration:
  - Central config with extensive env toggles (detection, gates, funder scan, image, auto‑buy, sender/jito, fees, timings).
  - Files: src/config.ts, .env

3) Next Steps / Roadmap
- Auto‑buy (finalize and enable):
  - Provide a valid Jito tip account; test Sender bundle path end‑to‑end.
  - Add cooldown/concurrency guard and quote‑drift guard (MAX_QUOTE_DRIFT_BPS) at send‑time.
  - Define retry and fallback policy (bounded bundle retries → single RPC send) with time budgets.

- Testing & Validation:
  - Dry‑run mode: log would‑buy decisions without sending; compare hit rate.
  - E2E tests on a dev wallet with tiny BUY_SOL; assert inclusion/confirm times.
  - Unit tests for gates (social parsing, creator initial buy, funder detection).

- Backtesting & Simulation:
  - Use captured “decision snapshot” logs to run pretend snipes, compute PnL with historical prices or a bonding‑curve simulator.
  - Parameter sweeps (BUY_SOL, slippage, thresholds) to tune acceptance criteria.

- Fine‑tuning Buy Conditions:
  - Keep image disabled; tighten Twitter gate if needed or add allowlist of trusted hosts.
  - Consider extra sanity (name/symbol rules, blacklist words already supported via env).

- Sell Condition Refactor:
  - Unify tracker with new positions; enforce min hold; choose between fixed TP/SL and trailing; add partial exits if desired.

- Observability & Ops:
  - Add a compact decisions JSONL for offline analysis.
  - Metrics counters (creates seen, accepted, buys sent, fills, rejections by reason).
  - Log rotation for LOG_FILE; optional debug levels per module.

- Reliability & Performance:
  - Rate‑limit metadata fetches; cache repeated URIs.
  - Multi‑RPC fallback, region selection for Sender/Jito.
  - SQLite: standardize on Node LTS to use better‑sqlite3 and retire JSON fallback.

4) Notes & Relevant Details
- Running:
  - Build: npm run build
  - Short health run: RUN_FOR_SECONDS=10 node dist/index.js
  - Enable auto‑buy by setting AUTO_BUY_ENABLED=true and JITO_TIP_ACCOUNT in .env

- Data storage:
  - SQLite at data/app.db (WAL mode creates -wal/-shm files). JSON fallback at data/store.json.
  - creators: first‑time creator checks; known_creators: manual blacklist; creator_funders: visibility of (creator,funder) edges.

- Env highlights (see .env):
  - Gates: REQUIRE_TWITTER_HANDLE_MATCH, CREATOR_MAX_INITIAL_BUY_SOL, CREATOR_REQUIRE_FIRST_TIME, CREATOR_FUNDER_BLACKLIST_CHECK, FUNDER_SIG_LIMIT.
  - Auto‑buy: AUTO_BUY_ENABLED, BUY_SOL, MAX_SLIPPAGE_BPS, PRIORITY_FEE_SOL, MIN_CREATE_MS, MAX_CREATE_AGE_MS, MAX_QUOTE_DRIFT_BPS.
  - Sender/Jito: JITO_ENABLED, JITO_TIP_SOL, JITO_TIP_ACCOUNT, HELIUS_SENDER_URL (optional), SENDER_COMMITMENT, SENDER_WAIT_MS.

- Security:
  - Keep SOLANA_PRIVATE_KEY in .env only for local; do not commit secrets.
  - Use minimal BUY_SOL while testing; double‑check gates before enabling buys in production.

This document is a living summary. Keep it aligned with code in:
- src/sources/onchainCreateDetector.ts
- src/gates/social.ts, src/gates/onchain.ts
- src/store_sqlite.ts, src/store.ts
- src/autoBuy.ts, src/sender/jito_jsonrpc.ts, src/sender/jito.ts
- src/index.ts, src/config.ts, .env


Possible buy conditions
1. for ones that have a volume spike within the first 2 seconds of launch 
2. for ones that dump and then re-pump again. entry after the initial dump. 
3. fixed tp over trailing because of insta dump risk where trailing cant cover quickly enough
4. 